<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Aritmatika - Petualangan Antariksa</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #4361ee;
            --primary-dark: #3a0ca3;
            --secondary: #f72585;
            --success: #4cc9f0;
            --danger: #f94144;
            --warning: #f8961e;
            --info: #4895ef;
            --light: #f8f9fa;
            --dark: #212529;
            --bg-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            --space-bg: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: var(--space-bg);
            color: white;
            touch-action: manipulation;
            overflow: hidden;
            margin: 0;
            padding: 0;
            height: 100vh;
        }

        .game-container {
            max-width: 100%;
            margin: 0 auto;
            padding: 15px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stats {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .stat-box {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .stat-icon {
            font-size: 1.5rem;
        }

        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mode-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 50px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-family: 'Poppins', sans-serif;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .mode-btn.active {
            background: var(--warning);
            color: var(--dark);
            box-shadow: 0 0 15px rgba(248, 150, 30, 0.5);
        }

        .game-area {
            display: flex;
            flex-grow: 1;
            gap: 20px;
            overflow: hidden;
            position: relative;
        }

        .maze-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            min-height: 0;
        }

        .maze {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-gap: 2px;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 12px;
            width: 100%;
            height: 100%;
            max-width: 500px;
            max-height: 500px;
            position: relative;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .cell {
            width: 100%;
            height: 0;
            padding-bottom: 100%;
            position: relative;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            transition: all 0.3s ease;
            overflow: hidden;
            background-image: url('https://www.transparenttextures.com/patterns/dark-stars.png');
        }

        .cell-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wall {
            background: rgba(0, 0, 0, 0.6);
            background-image: linear-gradient(45deg, rgba(0,0,0,0.3) 25%, transparent 25%, transparent 50%, rgba(0,0,0,0.3) 50%, rgba(0,0,0,0.3) 75%, transparent 75%, transparent 100%);
            background-size: 15px 15px;
        }

        .player {
            background: #4cc9f0;
            border-radius: 50%;
            width: 80%;
            height: 80%;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(76, 201, 240, 0.8);
            position: relative;
            z-index: 2;
            animation: pulse 1.5s infinite alternate;
        }

        .player::after {
            content: "";
            position: absolute;
            top: 15%;
            left: 15%;
            width: 20%;
            height: 20%;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
        }

        .path {
            background: rgba(76, 201, 240, 0.3);
            box-shadow: inset 0 0 10px rgba(76, 201, 240, 0.5);
        }

        .checkpoint {
            background: var(--info);
            animation: pulse 2s infinite;
            box-shadow: 0 0 15px rgba(72, 149, 239, 0.6);
        }

        .wrong-path {
            background: rgba(255, 87, 34, 0.5);
        }

        .exit {
            background: var(--light);
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 20px rgba(11, 225, 25, 0.7);
        }

        .health-chest {
            background: var(--secondary);
            animation: pulse 1s infinite;
            box-shadow: 0 0 15px rgba(247, 37, 133, 0.6);
        }

        .alien {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            background: rgba(249, 65, 68, 0.7);
            animation: shake 0.5s infinite alternate;
        }
        
        .alien-emoji {
            font-size: 1.5rem;
            filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));
            z-index: 2;
        }
        
        .alien-health {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 5px;
            background-color: red;
            border-radius: 0 0 5px 5px;
            transition: width 0.3s;
            z-index: 1;
        }
        
        .alien-power {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 3px black;
            z-index: 3;
        }

        .alien-defeated {
            background: rgba(158, 158, 158, 0.5);
            opacity: 0.5;
        }

        .weapon-power {
            position: absolute;
            top: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 5px;
            border-radius: 0 5px 0 5px;
            font-size: 0.7rem;
            font-weight: bold;
            z-index: 10;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes shake {
            0% { transform: translateX(-2px) rotate(-5deg); }
            100% { transform: translateX(2px) rotate(5deg); }
        }

        /* Controls Section */
        .controls-section {
            display: flex;
            justify-content: center;
            padding: 15px 0;
            gap: 20px;
        }

        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            border: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .control-btn:active {
            transform: translateY(1px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .dpad {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 12px;
            margin: 0 auto;
        }

        .dpad-btn {
            width: 65px;
            height: 65px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border: none;
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .dpad-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            background: rgba(255, 255, 255, 0.2);
        }

        .dpad-btn:active {
            transform: translateY(1px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .dpad-btn.up { grid-area: up; }
        .dpad-btn.left { grid-area: left; }
        .dpad-btn.right { grid-area: right; }
        .dpad-btn.down { grid-area: down; }

        .manual-controls {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 15px;
            width: 220px;
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 20px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center;
            color: var(--dark);
            animation: modalAppear 0.3s ease-out;
        }

        @keyframes modalAppear {
            from { transform: scale(0.9); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal-title {
            font-family: 'Fredoka One', cursive;
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 1.8rem;
        }

        .modal-text {
            margin-bottom: 20px;
            font-size: 1.1rem;
            line-height: 1.5;
        }

        .modal-input {
            width: 100%;
            padding: 15px;
            margin: 15px 0;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1.2rem;
            text-align: center;
            transition: all 0.3s;
        }

        .modal-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(67, 97, 238, 0.3);
            outline: none;
        }

        .modal-btn {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 25px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin-top: 10px;
            box-shadow: 0 4px 10px rgba(67, 97, 238, 0.3);
        }

        .modal-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(67, 97, 238, 0.4);
        }

        .modal-btn:active {
            transform: translateY(1px);
        }

        /* Battle Modal */
        .battle-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 10px;
        }
        
        .battle-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .battle-stat-value {
            font-weight: bold;
            font-size: 1.3rem;
        }
        
        .battle-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .battle-action-btn {
            padding: 10px;
            border: none;
            border-radius: 10px;
            background: var(--primary);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .battle-action-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }
        
        .battle-action-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .battle-result {
            font-size: 1.2rem;
            margin: 15px 0;
            font-weight: bold;
            color: var(--dark);
            min-height: 40px;
        }

        /* Tutorial Overlay */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            flex-direction: column;
            color: white;
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(5px);
        }

        .tutorial-content {
            max-width: 500px;
            width: 90%;
            background: rgba(67, 97, 238, 0.9);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.1);
            margin: 20px;
        }

        .tutorial-title {
            font-family: 'Fredoka One', cursive;
            font-size: 2rem;
            margin-bottom: 20px;
            color: white;
            line-height: 1.2;
        }

        .tutorial-text {
            margin-bottom: 15px;
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .tutorial-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .tutorial-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95rem;
            text-align: left;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .tutorial-icon {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .tutorial-icon.player {
            background: #4cc9f0;
            border-radius: 50%;
        }

        .tutorial-icon.exit {
            background: white;
            animation: pulse 1.5s infinite;
        }

        .tutorial-icon.checkpoint {
            background: #4895ef;
            animation: pulse 2s infinite;
        }

        .tutorial-icon.alien {
            background: #f94144;
        }

        .tutorial-icon.health-chest {
            background: #f72585;
            animation: pulse 1s infinite;
        }

        .tutorial-icon.path {
            background: rgba(76, 201, 240, 0.3);
        }

        .tutorial-btn {
            margin-top: 20px;
            padding: 12px 30px;
            background: var(--warning);
            color: var(--dark);
            border: none;
            border-radius: 50px;
            font-weight: bold;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(248, 150, 30, 0.4);
            font-family: 'Poppins', sans-serif;
        }

        .tutorial-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(248, 150, 30, 0.5);
            background: #f9a03f;
        }

        .tutorial-btn:active {
            transform: translateY(1px);
        }

        /* Effects */
        .explosion {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: radial-gradient(circle, #ff5722 0%, #ff9800 50%, transparent 70%);
            opacity: 0;
            z-index: 3;
            pointer-events: none;
            border-radius: 5px;
        }

        @keyframes explosion {
            0% { transform: scale(0.3); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        .confetti {
            position: absolute;
            width: 12px;
            height: 12px;
            opacity: 0;
            z-index: 4;
            pointer-events: none;
        }

        @keyframes confetti-fall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
        }

        .health-up {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: radial-gradient(circle, #4CAF50 0%, #2E7D32 50%, transparent 70%);
            opacity: 0;
            z-index: 3;
            pointer-events: none;
            border-radius: 5px;
        }

        @keyframes health-up {
            0% { transform: scale(0.3); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        .power-up {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: radial-gradient(circle, #ffeb3b 0%, #ffc107 50%, transparent 70%);
            opacity: 0;
            z-index: 3;
            pointer-events: none;
            border-radius: 5px;
        }

        @keyframes power-up {
            0% { transform: scale(0.3); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        /* Planet Info */
        .planet-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
            font-size: 0.9rem;
            z-index: 5;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
            }
            
            .manual-controls {
                width: 100%;
                margin-top: 15px;
            }
            
            .dpad-btn, .control-btn {
                width: 60px;
                height: 60px;
                font-size: 1.5rem;
            }
            
            .modal-content {
                padding: 20px;
            }

            .tutorial-content {
                padding: 20px;
            }
            
            .tutorial-title {
                font-size: 1.5rem;
            }
            
            .tutorial-text {
                font-size: 1rem;
            }
            
            .tutorial-grid {
                grid-template-columns: 1fr;
            }
            
            .tutorial-item {
                font-size: 0.9rem;
            }
            
            .tutorial-btn {
                padding: 10px 20px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="tutorial-overlay" id="tutorial-overlay">
        <div class="tutorial-content">
            <h2 class="tutorial-title">Super Aritmatika - Petualangan Antariksa</h2>
            <p class="tutorial-text">Selamat datang di petualangan Super Aritmatika! Kamu harus menyelamatkan planet-planet dari serangan alien dengan menyelesaikan soal matematika.</p>
            
            <div class="tutorial-grid">
                <div class="tutorial-item">
                    <div class="tutorial-icon player"></div>
                    <span>Karakter Pemain</span>
                </div>
                <div class="tutorial-item">
                    <div class="tutorial-icon exit"></div>
                    <span>Pintu Keluar (Planet Selanjutnya)</span>
                </div>
                <div class="tutorial-item">
                    <div class="tutorial-icon checkpoint"></div>
                    <span>Checkpoint Matematika</span>
                </div>
                <div class="tutorial-item">
                    <div class="tutorial-icon alien">👽</div>
                    <span>Alien (Kalahkan dengan senjata matematika)</span>
                </div>
                <div class="tutorial-item">
                    <div class="tutorial-icon health-chest"></div>
                    <span>Kotak Kesehatan</span>
                </div>
                <div class="tutorial-item">
                    <div class="tutorial-icon path"></div>
                    <span>Jalan yang Dilalui</span>
                </div>
            </div>
            
            <p class="tutorial-text">Setiap alien memiliki kekuatan angka. Untuk mengalahkannya, jawab soal matematika untuk meningkatkan kekuatan senjatamu!</p>
            
            <button class="tutorial-btn" id="start-btn">Mulai Petualangan!</button>
        </div>
    </div>

    <div class="game-container">
        <div class="header">
            <div class="stats">
                <div class="stat-box">
                    <span class="stat-icon">🚀</span>
                    <span id="planet">Merkurius</span>
                </div>
                <div class="stat-box">
                    <span class="stat-icon">❤️</span>
                    <span id="lives">3</span>
                </div>
                <div class="stat-box">
                    <span class="stat-icon">⚡</span>
                    <span id="weapon-power">5</span>
                </div>
            </div>
        </div>
        
        <div class="planet-info">
            Planet: <span id="current-planet">Merkurius</span><br>
            Target: Kumpulkan <span id="target-points">3</span> poin
        </div>
        
        <div class="game-area">
            <div class="maze-container">
                <div class="maze" id="maze">
                    <!-- Labirin akan diisi oleh JavaScript -->
                </div>
            </div>
            
            <div class="manual-controls" id="manual-controls">
                <div class="dpad">
                    <button class="dpad-btn up" id="up-btn">↑</button>
                    <button class="dpad-btn left" id="left-btn">←</button>
                    <button class="dpad-btn right" id="right-btn">→</button>
                    <button class="dpad-btn down" id="down-btn">↓</button>
                </div>
            </div>
        </div>
        
        <div class="controls-section">
            <button class="control-btn" id="pause-btn">⏸️</button>
            <button class="control-btn" id="hint-btn">💡</button>
            <button class="tutorial-btn" id="tutorial-btn">❓ Tutorial</button>
        </div>
    </div>

    <!-- Math Question Modal -->
    <div id="question-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3 class="modal-title">Pertanyaan Matematika</h3>
            <p class="modal-text" id="question-text"></p>
            <input type="number" id="answer-input" class="modal-input" placeholder="Masukkan jawaban...">
            <button id="submit-answer" class="modal-btn">Submit</button>
        </div>
    </div>

    <!-- Battle Modal -->
    <div id="battle-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3 class="modal-title">Pertempuran Melawan Alien!</h3>
            
            <div class="battle-info">
                <div class="battle-stat">
                    <div>Kekuatanmu</div>
                    <div class="battle-stat-value" id="player-power">5</div>
                </div>
                <div class="battle-stat">
                    <div>VS</div>
                </div>
                <div class="battle-stat">
                    <div>Kekuatan Alien</div>
                    <div class="battle-stat-value" id="alien-power">8</div>
                </div>
            </div>
            
            <p class="modal-text">Jawab soal matematika untuk meningkatkan kekuatan senjatamu!</p>
            
            <div class="battle-actions">
                <button id="battle-attack" class="battle-action-btn">Serang dengan Senjata (Kekuatan: <span id="current-weapon-power">5</span>)</button>
                <button id="battle-math" class="battle-action-btn">Selesaikan Soal untuk Upgrade Senjata</button>
                <button id="battle-flee" class="battle-action-btn" style="background: var(--danger);">Lari (Kehilangan 1 nyawa)</button>
            </div>
            
            <div class="battle-result" id="battle-result"></div>
        </div>
    </div>

    <!-- Level Complete Modal -->
    <div id="level-complete-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3 class="modal-title">Planet Diselamatkan! 🎉</h3>
            <p class="modal-text">Kamu berhasil menyelamatkan planet <span id="completed-planet">Merkurius</span>!</p>
            <p class="modal-text">Senjata matematikamu meningkat!</p>
            <button id="next-level-btn" class="modal-btn">Lanjut ke Planet Selanjutnya</button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3 class="modal-title">Game Over! ☠️</h3>
            <p class="modal-text">Kamu kehabisan nyawa dalam petualangan ini.</p>
            <button id="restart-btn" class="modal-btn">Mulai Ulang Petualangan</button>
        </div>
    </div>

    <!-- Audio Elements -->
    <audio id="correct-sound" src="https://assets.mixkit.co/sfx/preview/mixkit-correct-answer-tone-2870.mp3" preload="auto"></audio>
    <audio id="wrong-sound" src="https://assets.mixkit.co/sfx/preview/mixkit-wrong-answer-fail-notification-946.mp3" preload="auto"></audio>
    <audio id="move-sound" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3" preload="auto"></audio>
    <audio id="explosion-sound" src="https://assets.mixkit.co/sfx/preview/mixkit-explosion-impact-1684.mp3" preload="auto"></audio>
    <audio id="win-sound" src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" preload="auto"></audio>
    <audio id="health-sound" src="https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3" preload="auto"></audio>
    <audio id="alien-sound" src="https://assets.mixkit.co/sfx/preview/mixkit-ominous-drums-227.mp3" preload="auto"></audio>
    <audio id="battle-sound" src="https://assets.mixkit.co/sfx/preview/mixkit-game-show-suspense-waiting-668.mp3" preload="auto"></audio>
    <audio id="powerup-sound" src="https://assets.mixkit.co/sfx/preview/mixkit-extra-bonus-in-a-video-game-2045.mp3" preload="auto"></audio>

    <!-- JavaScript -->
    <script>
        // Game state
        const gameState = {
            level: 1,
            lives: 3,
            maxLives: 5,
            weaponPower: 5,
            playerPosition: { x: 1, y: 1 },
            exitPosition: { x: 13, y: 13 },
            maze: [],
            mazeSize: 15,
            isPaused: false,
            checkpoints: [],
            checkpointsReached: [],
            aliens: [],
            defeatedAliens: [],
            healthChests: [],
            collectedChests: [],
            visitedCells: [],
            hintPath: [],
            showHint: false,
            firstTimePlaying: true,
            currentBattleAlien: null,
            planets: [
                { name: "Merkurius", difficulty: 1, targetPoints: 3, bgColor: "#A9A9A9" },
                { name: "Venus", difficulty: 2, targetPoints: 4, bgColor: "#E6C229" },
                { name: "Bumi", difficulty: 3, targetPoints: 5, bgColor: "#2E86C1" },
                { name: "Mars", difficulty: 4, targetPoints: 6, bgColor: "#E74C3C" },
                { name: "Jupiter", difficulty: 5, targetPoints: 7, bgColor: "#F5B041" },
                { name: "Saturnus", difficulty: 6, targetPoints: 8, bgColor: "#F1C40F" },
                { name: "Uranus", difficulty: 7, targetPoints: 9, bgColor: "#5DADE2" },
                { name: "Neptunus", difficulty: 8, targetPoints: 10, bgColor: "#3498DB" }
            ],
            alienTypes: [
                { name: "Alien Kecil", emoji: "👽", power: 3, health: 1, message: "Alien kecil tapi licik!" },
                { name: "Alien Sedang", emoji: "👾", power: 5, health: 2, message: "Alien sedang dengan kekuatan cukup!" },
                { name: "Alien Besar", emoji: "🤖", power: 8, health: 3, message: "Alien besar dan kuat!" },
                { name: "Alien Raksasa", emoji: "👹", power: 12, health: 4, message: "Alien raksasa yang menakutkan!" },
                { name: "Alien Boss", emoji: "🐉", power: 15, health: 5, message: "Alien Boss dengan kekuatan dahsyat!" }
            ]
        };

        // DOM elements
        const elements = {
            maze: document.getElementById('maze'),
            livesDisplay: document.getElementById('lives'),
            weaponPowerDisplay: document.getElementById('weapon-power'),
            planetDisplay: document.getElementById('planet'),
            currentPlanetDisplay: document.getElementById('current-planet'),
            targetPointsDisplay: document.getElementById('target-points'),
            tutorialOverlay: document.getElementById('tutorial-overlay'),
            startBtn: document.getElementById('start-btn'),
            tutorialBtn: document.getElementById('tutorial-btn'),
            manualControls: document.getElementById('manual-controls'),
            upBtn: document.getElementById('up-btn'),
            leftBtn: document.getElementById('left-btn'),
            rightBtn: document.getElementById('right-btn'),
            downBtn: document.getElementById('down-btn'),
            pauseBtn: document.getElementById('pause-btn'),
            hintBtn: document.getElementById('hint-btn'),
            questionModal: document.getElementById('question-modal'),
            questionText: document.getElementById('question-text'),
            answerInput: document.getElementById('answer-input'),
            submitAnswer: document.getElementById('submit-answer'),
            battleModal: document.getElementById('battle-modal'),
            playerPowerDisplay: document.getElementById('player-power'),
            alienPowerDisplay: document.getElementById('alien-power'),
            currentWeaponPowerDisplay: document.getElementById('current-weapon-power'),
            battleAttackBtn: document.getElementById('battle-attack'),
            battleMathBtn: document.getElementById('battle-math'),
            battleFleeBtn: document.getElementById('battle-flee'),
            battleResult: document.getElementById('battle-result'),
            levelCompleteModal: document.getElementById('level-complete-modal'),
            completedPlanetDisplay: document.getElementById('completed-planet'),
            nextLevelBtn: document.getElementById('next-level-btn'),
            gameOverModal: document.getElementById('game-over-modal'),
            restartBtn: document.getElementById('restart-btn'),
            correctSound: document.getElementById('correct-sound'),
            wrongSound: document.getElementById('wrong-sound'),
            moveSound: document.getElementById('move-sound'),
            explosionSound: document.getElementById('explosion-sound'),
            winSound: document.getElementById('win-sound'),
            healthSound: document.getElementById('health-sound'),
            alienSound: document.getElementById('alien-sound'),
            battleSound: document.getElementById('battle-sound'),
            powerupSound: document.getElementById('powerup-sound')
        };

        // Initialize the game
        function initGame() {
            // Initialize game state
            resetGameState();
            
            // Setup event listeners
            setupEventListeners();
            
            // Check if first time playing
            const hasPlayedBefore = localStorage.getItem('hasPlayedBefore');
            if (!hasPlayedBefore) {
                showTutorial();
                localStorage.setItem('hasPlayedBefore', 'true');
                gameState.firstTimePlaying = true;
            } else {
                gameState.firstTimePlaying = false;
                startGame();
            }
        }

        function setupEventListeners() {
            // Tutorial controls
            elements.startBtn.addEventListener('click', startGame);
            elements.tutorialBtn.addEventListener('click', showTutorial);
            
            // Movement controls
            elements.upBtn.addEventListener('click', () => movePlayer(0, -1));
            elements.leftBtn.addEventListener('click', () => movePlayer(-1, 0));
            elements.rightBtn.addEventListener('click', () => movePlayer(1, 0));
            elements.downBtn.addEventListener('click', () => movePlayer(0, 1));
            
            // Game controls
            elements.pauseBtn.addEventListener('click', togglePause);
            elements.hintBtn.addEventListener('click', showHint);
            
            // Modal controls
            elements.submitAnswer.addEventListener('click', checkAnswer);
            elements.battleAttackBtn.addEventListener('click', attackAlien);
            elements.battleMathBtn.addEventListener('click', showMathQuestionInBattle);
            elements.battleFleeBtn.addEventListener('click', fleeFromBattle);
            elements.nextLevelBtn.addEventListener('click', nextLevel);
            elements.restartBtn.addEventListener('click', restartGame);
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (gameState.isPaused) return;
                switch (e.key) {
                    case 'ArrowUp': case 'w': case 'W': movePlayer(0, -1); break;
                    case 'ArrowLeft': case 'a': case 'A': movePlayer(-1, 0); break;
                    case 'ArrowRight': case 'd': case 'D': movePlayer(1, 0); break;
                    case 'ArrowDown': case 's': case 'S': movePlayer(0, 1); break;
                }
            });
        }

        function showTutorial() {
            elements.tutorialOverlay.style.display = 'flex';
        }

        function startGame() {
            elements.tutorialOverlay.style.display = 'none';
            resetGameState();
            generateMaze();
            renderMaze();
            updateUI();
        }

        // Reset game state for a new level
        function resetGameState() {
            const planet = gameState.planets[gameState.level - 1] || gameState.planets[gameState.planets.length - 1];
            
            gameState.playerPosition = { x: 1, y: 1 };
            gameState.exitPosition = { x: gameState.mazeSize - 2, y: gameState.mazeSize - 2 };
            gameState.maze = [];
            gameState.checkpoints = [];
            gameState.checkpointsReached = [];
            gameState.aliens = [];
            gameState.defeatedAliens = [];
            gameState.healthChests = [];
            gameState.collectedChests = [];
            gameState.visitedCells = [];
            gameState.hintPath = [];
            gameState.showHint = false;
            gameState.currentBattleAlien = null;
            
            // Always add starting position to visited cells
            gameState.visitedCells.push(`${gameState.playerPosition.x},${gameState.playerPosition.y}`);
            
            // Update planet info
            elements.currentPlanetDisplay.textContent = planet.name;
            elements.targetPointsDisplay.textContent = planet.targetPoints;
            document.body.style.background = planet.bgColor;
        }

        // Generate the maze
        function generateMaze() {
            // Initialize maze with all walls
            for (let y = 0; y < gameState.mazeSize; y++) {
                gameState.maze[y] = [];
                for (let x = 0; x < gameState.mazeSize; x++) {
                    gameState.maze[y][x] = { isWall: true };
                }
            }

            // Create paths
            carvePaths(1, 1);

            // Ensure exit is reachable
            gameState.maze[gameState.exitPosition.y][gameState.exitPosition.x].isWall = false;

            // Connect any isolated areas
            connectIsolatedAreas();

            // Add game elements
            addCheckpoints();
            addAliens();
            addHealthChests();
            generateHintPath();
        }

        // Recursive backtracking maze generation
        function carvePaths(x, y) {
            gameState.maze[y][x].isWall = false;
            
            const directions = [
                [1, 0], [-1, 0], [0, 1], [0, -1]
            ];
            
            // Shuffle directions
            for (let i = directions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [directions[i], directions[j]] = [directions[j], directions[i]];
            }
            
            for (const [dx, dy] of directions) {
                const nx = x + dx * 2;
                const ny = y + dy * 2;
                
                if (nx > 0 && nx < gameState.mazeSize - 1 && 
                    ny > 0 && ny < gameState.mazeSize - 1 && 
                    gameState.maze[ny][nx].isWall) {
                    gameState.maze[y + dy][x + dx].isWall = false;
                    carvePaths(nx, ny);
                }
            }
        }

        // Connect isolated areas
        function connectIsolatedAreas() {
            const visited = Array(gameState.mazeSize).fill().map(() => Array(gameState.mazeSize).fill(false));
            const areas = [];
            
            for (let y = 1; y < gameState.mazeSize - 1; y++) {
                for (let x = 1; x < gameState.mazeSize - 1; x++) {
                    if (!gameState.maze[y][x].isWall && !visited[y][x]) {
                        const area = [];
                        const queue = [{x, y}];
                        visited[y][x] = true;
                        
                        while (queue.length > 0) {
                            const current = queue.shift();
                            area.push(current);
                            
                            // Check neighbors
                            const neighbors = [
                                {x: current.x + 1, y: current.y},
                                {x: current.x - 1, y: current.y},
                                {x: current.x, y: current.y + 1},
                                {x: current.x, y: current.y - 1}
                            ];
                            
                            for (const neighbor of neighbors) {
                                if (neighbor.x > 0 && neighbor.x < gameState.mazeSize - 1 &&
                                    neighbor.y > 0 && neighbor.y < gameState.mazeSize - 1 &&
                                    !gameState.maze[neighbor.y][neighbor.x].isWall &&
                                    !visited[neighbor.y][neighbor.x]) {
                                    visited[neighbor.y][neighbor.x] = true;
                                    queue.push(neighbor);
                                }
                            }
                        }
                        
                        areas.push(area);
                    }
                }
            }
            
            // Connect areas if needed
            if (areas.length > 1) {
                for (let i = 1; i < areas.length; i++) {
                    const prevArea = areas[i-1];
                    const currentArea = areas[i];
                    
                    // Find closest points
                    let minDist = Infinity;
                    let bestPair = null;
                    
                    for (const p1 of prevArea) {
                        for (const p2 of currentArea) {
                            const dist = Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
                            if (dist < minDist) {
                                minDist = dist;
                                bestPair = {p1, p2};
                            }
                        }
                    }
                    
                    // Create path
                    if (bestPair) {
                        const {p1, p2} = bestPair;
                        let x = p1.x;
                        let y = p1.y;
                        
                        while (x !== p2.x || y !== p2.y) {
                            if (x < p2.x) x++;
                            else if (x > p2.x) x--;
                            else if (y < p2.y) y++;
                            else if (y > p2.y) y--;
                            
                            gameState.maze[y][x].isWall = false;
                        }
                    }
                }
            }
        }

        // Add checkpoints
        function addCheckpoints() {
            const planet = gameState.planets[gameState.level - 1] || gameState.planets[gameState.planets.length - 1];
            const numCheckpoints = planet.targetPoints;
            
            for (let i = 0; i < numCheckpoints; i++) {
                let x, y;
                let attempts = 0;
                const maxAttempts = 100;
                
                do {
                    x = Math.floor(Math.random() * (gameState.mazeSize - 4)) + 2;
                    y = Math.floor(Math.random() * (gameState.mazeSize - 4)) + 2;
                    attempts++;
                    
                    if (attempts >= maxAttempts) {
                        x = Math.floor(Math.random() * (gameState.mazeSize - 2)) + 1;
                        y = Math.floor(Math.random() * (gameState.mazeSize - 2)) + 1;
                        break;
                    }
                } while (
                    gameState.maze[y][x].isWall || 
                    (x === gameState.playerPosition.x && y === gameState.playerPosition.y) ||
                    (x === gameState.exitPosition.x && y === gameState.exitPosition.y) ||
                    gameState.checkpoints.some(cp => cp.x === x && cp.y === y) ||
                    isTooCloseToOtherPoints(x, y)
                );
                
                gameState.checkpoints.push({ x, y });
            }
        }

        // Check if position is too close to other points
        function isTooCloseToOtherPoints(x, y) {
            const minDistance = 3;
            
            // Check distance to player start
            if (Math.abs(x - gameState.playerPosition.x) + Math.abs(y - gameState.playerPosition.y) < minDistance) {
                return true;
            }
            
            // Check distance to exit
            if (Math.abs(x - gameState.exitPosition.x) + Math.abs(y - gameState.exitPosition.y) < minDistance) {
                return true;
            }
            
            // Check distance to other checkpoints
            for (const cp of gameState.checkpoints) {
                if (Math.abs(x - cp.x) + Math.abs(y - cp.y) < minDistance) {
                    return true;
                }
            }
            
            return false;
        }

        // Add aliens
        function addAliens() {
            const planet = gameState.planets[gameState.level - 1] || gameState.planets[gameState.planets.length - 1];
            const maxAliens = Math.min(3 + Math.floor(planet.difficulty / 2), 5);
            
            // Create weighted alien pool based on difficulty
            const alienPool = [];
            for (const alienType of gameState.alienTypes) {
                // Higher difficulty planets have stronger aliens
                const weight = Math.max(1, 5 - Math.abs(alienType.power - planet.difficulty * 1.5));
                for (let i = 0; i < weight; i++) {
                    alienPool.push(alienType);
                }
            }
            
            // Place aliens
            for (let i = 0; i < maxAliens; i++) {
                let x, y;
                let attempts = 0;
                const maxAttempts = 100;
                
                // Get random alien type from weighted pool
                const alienType = alienPool[Math.floor(Math.random() * alienPool.length)];
                
                do {
                    x = Math.floor(Math.random() * (gameState.mazeSize - 4)) + 2;
                    y = Math.floor(Math.random() * (gameState.mazeSize - 4)) + 2;
                    attempts++;
                    
                    if (attempts >= maxAttempts) {
                        x = Math.floor(Math.random() * (gameState.mazeSize - 2)) + 1;
                        y = Math.floor(Math.random() * (gameState.mazeSize - 2)) + 1;
                        break;
                    }
                } while (
                    gameState.maze[y][x].isWall || 
                    (x === gameState.playerPosition.x && y === gameState.playerPosition.y) ||
                    (x === gameState.exitPosition.x && y === gameState.exitPosition.y) ||
                    gameState.checkpoints.some(cp => cp.x === x && cp.y === y) ||
                    gameState.aliens.some(a => a.x === x && a.y === y) ||
                    isTooCloseToOtherPoints(x, y)
                );
                
                // Scale alien difficulty with level
                const scaledAlien = {
                    ...alienType,
                    health: Math.min(
                        alienType.health + Math.floor(planet.difficulty / 3),
                        alienType.health * 2
                    )
                };
                
                gameState.aliens.push({
                    x, 
                    y,
                    type: scaledAlien,
                    currentHealth: scaledAlien.health
                });
            }
        }

        // Add health chests
        function addHealthChests() {
            if (gameState.lives >= gameState.maxLives) return;

            let x, y;
            let attempts = 0;
            const maxAttempts = 100;
            
            do {
                x = Math.floor(Math.random() * (gameState.mazeSize - 4)) + 2;
                y = Math.floor(Math.random() * (gameState.mazeSize - 4)) + 2;
                attempts++;
                
                if (attempts >= maxAttempts) {
                    x = Math.floor(Math.random() * (gameState.mazeSize - 2)) + 1;
                    y = Math.floor(Math.random() * (gameState.mazeSize - 2)) + 1;
                    break;
                }
            } while (
                gameState.maze[y][x].isWall || 
                (x === gameState.playerPosition.x && y === gameState.playerPosition.y) ||
                (x === gameState.exitPosition.x && y === gameState.exitPosition.y) ||
                gameState.checkpoints.some(cp => cp.x === x && cp.y === y) ||
                gameState.aliens.some(a => a.x === x && a.y === y) ||
                gameState.healthChests.some(h => h.x === x && h.y === y)
            );
            
            gameState.healthChests.push({ x, y });
        }

        // Generate hint path
        function generateHintPath() {
            const queue = [];
            const visited = {};
            const parent = {};
            
            const startKey = `${gameState.playerPosition.x},${gameState.playerPosition.y}`;
            queue.push(gameState.playerPosition);
            visited[startKey] = true;
            
            while (queue.length > 0) {
                const current = queue.shift();
                const currentKey = `${current.x},${current.y}`;
                
                if (current.x === gameState.exitPosition.x && current.y === gameState.exitPosition.y) {
                    const path = [];
                    let node = currentKey;
                    
                    while (node !== startKey) {
                        path.unshift(node);
                        node = parent[node];
                    }
                    
                    gameState.hintPath = path.map(pos => {
                        const [x, y] = pos.split(',').map(Number);
                        return { x, y };
                    });
                    return;
                }
                
                const directions = [
                    { dx: 1, dy: 0 },
                    { dx: -1, dy: 0 },
                    { dx: 0, dy: 1 },
                    { dx: 0, dy: -1 }
                ];
                
                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    const nextKey = `${nx},${ny}`;
                    
                    if (nx >= 0 && nx < gameState.mazeSize && 
                        ny >= 0 && ny < gameState.mazeSize && 
                        !gameState.maze[ny][nx].isWall && 
                        !visited[nextKey]) {
                        visited[nextKey] = true;
                        parent[nextKey] = currentKey;
                        queue.push({ x: nx, y: ny });
                    }
                }
            }
        }

        // Render the maze
        function renderMaze() {
            elements.maze.innerHTML = '';
            elements.maze.style.gridTemplateColumns = `repeat(${gameState.mazeSize}, 1fr)`;
            
            for (let y = 0; y < gameState.mazeSize; y++) {
                for (let x = 0; x < gameState.mazeSize; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    // Set wall or path
                    if (gameState.maze[y][x].isWall) {
                        cell.classList.add('wall');
                    } else {
                        // Show hint path if enabled
                        if (gameState.showHint && gameState.hintPath.some(pos => pos.x === x && pos.y === y)) {
                            cell.classList.add('path');
                        }
                        
                        // Show visited path (only the current path)
                        const visitedIndex = gameState.visitedCells.indexOf(`${x},${y}`);
                        if (visitedIndex !== -1) {
                            cell.classList.add('path');
                        }
                        
                        // Show wrong path only in hint mode
                        if (gameState.showHint && visitedIndex !== -1 && 
                            !gameState.hintPath.some(pos => pos.x === x && pos.y === y)) {
                            cell.classList.add('wrong-path');
                        }
                    }
                    
                    // Add player
                    if (x === gameState.playerPosition.x && y === gameState.playerPosition.y) {
                        const player = document.createElement('div');
                        player.className = 'player';
                        cell.appendChild(player);
                        
                        // Show weapon power
                        const weaponPower = document.createElement('div');
                        weaponPower.className = 'weapon-power';
                        weaponPower.textContent = gameState.weaponPower;
                        cell.appendChild(weaponPower);
                    }
                    
                    // Add exit
                    if (x === gameState.exitPosition.x && y === gameState.exitPosition.y) {
                        cell.classList.add('exit');
                    }
                    
                    // Add checkpoints
                    const checkpoint = gameState.checkpoints.find(cp => cp.x === x && cp.y === y);
                    if (checkpoint && !gameState.checkpointsReached.includes(`${x},${y}`)) {
                        cell.classList.add('checkpoint');
                    }
                    
                    // Add aliens
                    const alien = gameState.aliens.find(a => a.x === x && a.y === y);
                    if (alien && !gameState.defeatedAliens.includes(`${x},${y}`)) {
                        cell.classList.add('alien');
                        const alienEmoji = document.createElement('div');
                        alienEmoji.className = 'alien-emoji';
                        alienEmoji.textContent = alien.type.emoji;
                        cell.appendChild(alienEmoji);
                        
                        // Show alien power
                        const alienPower = document.createElement('div');
                        alienPower.className = 'alien-power';
                        alienPower.textContent = alien.type.power;
                        cell.appendChild(alienPower);
                        
                        // Show health bar if health > 1
                        if (alien.type.health > 1) {
                            const healthBar = document.createElement('div');
                            healthBar.className = 'alien-health';
                            healthBar.style.width = `${(alien.currentHealth / alien.type.health) * 100}%`;
                            cell.appendChild(healthBar);
                        }
                    }
                    
                    // Add health chests
                    const healthChest = gameState.healthChests.find(h => h.x === x && h.y === y);
                    if (healthChest && !gameState.collectedChests.includes(`${x},${y}`)) {
                        cell.classList.add('health-chest');
                    }
                    
                    elements.maze.appendChild(cell);
                }
            }
        }

        // Update UI
        function updateUI() {
            const planet = gameState.planets[gameState.level - 1] || gameState.planets[gameState.planets.length - 1];
            
            elements.livesDisplay.textContent = gameState.lives;
            elements.weaponPowerDisplay.textContent = gameState.weaponPower;
            elements.planetDisplay.textContent = planet.name;
            elements.currentPlanetDisplay.textContent = planet.name;
            elements.targetPointsDisplay.textContent = planet.targetPoints;
        }

        // Move player
        function movePlayer(dx, dy) {
            if (gameState.isPaused) return;
            
            const newX = gameState.playerPosition.x + dx;
            const newY = gameState.playerPosition.y + dy;
            
            if (newX < 0 || newX >= gameState.mazeSize || 
                newY < 0 || newY >= gameState.mazeSize || 
                gameState.maze[newY][newX].isWall) {
                return;
            }
            
            elements.moveSound.currentTime = 0;
            elements.moveSound.play();
            
            // Get the current path index if we're backtracking
            const currentPosIndex = gameState.visitedCells.indexOf(`${gameState.playerPosition.x},${gameState.playerPosition.y}`);
            const newPosIndex = gameState.visitedCells.indexOf(`${newX},${newY}`);
            
            // If we're moving to a previously visited cell, remove all cells after it
            if (newPosIndex !== -1) {
                gameState.visitedCells = gameState.visitedCells.slice(0, newPosIndex + 1);
            } else {
                // Add new position to visited cells
                gameState.visitedCells.push(`${newX},${newY}`);
            }
            
            gameState.playerPosition = { x: newX, y: newY };
            
            checkCheckpoint(newX, newY);
            checkAlien(newX, newY);
            checkHealthChest(newX, newY);
            checkExit(newX, newY);
            
            renderMaze();
        }

        // Check checkpoint
        function checkCheckpoint(x, y) {
            const checkpointIndex = gameState.checkpoints.findIndex(cp => cp.x === x && cp.y === y);
            
            if (checkpointIndex !== -1 && !gameState.checkpointsReached.includes(`${x},${y}`)) {
                showMathQuestion();
                gameState.checkpointsReached.push(`${x},${y}`);
            }
        }

        // Check alien
        function checkAlien(x, y) {
            const alienIndex = gameState.aliens.findIndex(a => a.x === x && a.y === y);
            
            if (alienIndex !== -1 && !gameState.defeatedAliens.includes(`${x},${y}`)) {
                gameState.currentBattleAlien = gameState.aliens[alienIndex];
                showBattle();
                elements.alienSound.currentTime = 0;
                elements.alienSound.play();
            }
        }

        // Check health chest
        function checkHealthChest(x, y) {
            const chestIndex = gameState.healthChests.findIndex(h => h.x === x && h.y === y);
            
            if (chestIndex !== -1 && !gameState.collectedChests.includes(`${x},${y}`)) {
                if (gameState.lives < gameState.maxLives) {
                    gameState.lives++;
                    elements.healthSound.currentTime = 0;
                    elements.healthSound.play();
                    showHealthUpEffect(x, y);
                }
                
                gameState.collectedChests.push(`${x},${y}`);
                updateUI();
            }
        }

        // Check exit
        function checkExit(x, y) {
            if (x === gameState.exitPosition.x && y === gameState.exitPosition.y) {
                const planet = gameState.planets[gameState.level - 1] || gameState.planets[gameState.planets.length - 1];
                
                if (gameState.checkpointsReached.length >= planet.targetPoints) {
                    elements.winSound.currentTime = 0;
                    elements.winSound.play();
                    showConfetti();
                    
                    setTimeout(() => {
                        showLevelComplete();
                    }, 2000);
                }
            }
        }

        // Show math question
        function showMathQuestion() {
            let question, answer;
            const operationTypes = [
                'addition', 'subtraction', 'multiplication', 'division',
                'addition-triple', 'subtraction-triple', 'sequence', 'comparison'
            ];
            
            const planet = gameState.planets[gameState.level - 1] || gameState.planets[gameState.planets.length - 1];
            let operationType;
            
            if (planet.difficulty < 3) {
                operationType = operationTypes[Math.floor(Math.random() * 4)];
            } else if (planet.difficulty < 6) {
                operationType = operationTypes[Math.floor(Math.random() * 6)];
            } else {
                operationType = operationTypes[Math.floor(Math.random() * operationTypes.length)];
            }
            
            switch (operationType) {
                case 'addition':
                    const a = Math.floor(Math.random() * (planet.difficulty * 5)) + 1;
                    const b = Math.floor(Math.random() * (planet.difficulty * 5)) + 1;
                    question = `${a} + ${b} = ?`;
                    answer = a + b;
                    break;
                    
                case 'subtraction':
                    const c = Math.floor(Math.random() * (planet.difficulty * 5)) + 1;
                    const d = Math.floor(Math.random() * (planet.difficulty * 5)) + 1;
                    question = `${Math.max(c, d)} - ${Math.min(c, d)} = ?`;
                    answer = Math.max(c, d) - Math.min(c, d);
                    break;
                    
                case 'multiplication':
                    const e = Math.floor(Math.random() * (planet.difficulty * 2)) + 1;
                    const f = Math.floor(Math.random() * (planet.difficulty * 2)) + 1;
                    question = `${e} × ${f} = ?`;
                    answer = e * f;
                    break;
                    
                case 'division':
                    const g = Math.floor(Math.random() * (planet.difficulty * 2)) + 1;
                    const h = Math.floor(Math.random() * (planet.difficulty * 2)) + 1;
                    const product = g * h;
                    question = `${product} ÷ ${g} = ?`;
                    answer = h;
                    break;
                    
                case 'addition-triple':
                    const i = Math.floor(Math.random() * (planet.difficulty * 3)) + 1;
                    const j = Math.floor(Math.random() * (planet.difficulty * 3)) + 1;
                    const k = Math.floor(Math.random() * (planet.difficulty * 3)) + 1;
                    question = `${i} + ${j} + ${k} = ?`;
                    answer = i + j + k;
                    break;
                    
                case 'subtraction-triple':
                    const l = Math.floor(Math.random() * (planet.difficulty * 3)) + 1;
                    const m = Math.floor(Math.random() * (planet.difficulty * 3)) + 1;
                    const n = Math.floor(Math.random() * (planet.difficulty * 3)) + 1;
                    const max = Math.max(l, m, n);
                    const min = Math.min(l, m, n);
                    const mid = l + m + n - max - min;
                    question = `${max} - ${mid} - ${min} = ?`;
                    answer = max - mid - min;
                    break;
                    
                case 'sequence':
                    const start = Math.floor(Math.random() * 10) + 1;
                    const step = Math.floor(Math.random() * 3) + 1;
                    const seqLength = Math.floor(Math.random() * 2) + 4;
                    let sequence = [];
                    for (let s = 0; s < seqLength; s++) {
                        sequence.push(start + s * step);
                    }
                    const missingPos = Math.floor(Math.random() * seqLength);
                    answer = sequence[missingPos];
                    sequence[missingPos] = '?';
                    question = `Lanjutkan pola: ${sequence.join(', ')}`;
                    break;
                    
                case 'comparison':
                    const o = Math.floor(Math.random() * (planet.difficulty * 5)) + 1;
                    const p = Math.floor(Math.random() * (planet.difficulty * 5)) + 1;
                    const q = Math.floor(Math.random() * (planet.difficulty * 5)) + 1;
                    const comparisonType = Math.floor(Math.random() * 3);
                    
                    switch (comparisonType) {
                        case 0:
                            question = `Berapa jumlah ${o} + ${p} + ${q}?`;
                            answer = o + p + q;
                            break;
                        case 1:
                            question = `Berapa selisih antara ${Math.max(o, p)} dan ${Math.min(o, p)}?`;
                            answer = Math.max(o, p) - Math.min(o, p);
                            break;
                        case 2:
                            question = `Jika ${o} × ${p} = ${o * p}, berapa ${o} × ${p} × ${q}?`;
                            answer = o * p * q;
                            break;
                    }
                    break;
            }
            
            elements.questionText.textContent = question;
            elements.answerInput.value = '';
            elements.questionModal.style.display = 'flex';
            elements.answerInput.focus();
            elements.questionModal.dataset.correctAnswer = answer;
        }

        // Check answer
        function checkAnswer() {
            const userAnswer = parseInt(elements.answerInput.value);
            const correctAnswer = parseInt(elements.questionModal.dataset.correctAnswer);
            
            if (userAnswer === correctAnswer) {
                elements.correctSound.currentTime = 0;
                elements.correctSound.play();
                
                // If in battle, increase weapon power
                if (gameState.currentBattleAlien) {
                    gameState.weaponPower += 2;
                    elements.powerupSound.currentTime = 0;
                    elements.powerupSound.play();
                    showPowerUpEffect(gameState.playerPosition.x, gameState.playerPosition.y);
                    updateBattleUI();
                }
                
                elements.questionModal.style.display = 'none';
            } else {
                elements.wrongSound.currentTime = 0;
                elements.wrongSound.play();
                elements.answerInput.value = '';
                elements.answerInput.focus();
            }
        }

        // Show battle
        function showBattle() {
            elements.battleSound.currentTime = 0;
            elements.battleSound.play();
            elements.battleResult.textContent = '';
            updateBattleUI();
            elements.battleModal.style.display = 'flex';
        }
        
        // Update battle UI
        function updateBattleUI() {
            elements.playerPowerDisplay.textContent = gameState.weaponPower;
            elements.alienPowerDisplay.textContent = gameState.currentBattleAlien.type.power;
            elements.currentWeaponPowerDisplay.textContent = gameState.weaponPower;
            
            // Disable attack button if weapon power is less than alien power
            elements.battleAttackBtn.disabled = gameState.weaponPower < gameState.currentBattleAlien.type.power;
        }

        // Attack alien
        function attackAlien() {
            if (gameState.weaponPower >= gameState.currentBattleAlien.type.power) {
                // Defeat the alien
                const alienKey = `${gameState.currentBattleAlien.x},${gameState.currentBattleAlien.y}`;
                gameState.defeatedAliens.push(alienKey);
                
                elements.battleResult.innerHTML = `
                    <div>Kamu mengalahkan ${gameState.currentBattleAlien.type.name} dengan senjata matematikamu!</div>
                    <div>Kekuatan senjata: ${gameState.weaponPower} vs Kekuatan alien: ${gameState.currentBattleAlien.type.power}</div>
                `;
                
                elements.explosionSound.currentTime = 0;
                elements.explosionSound.play();
                showExplosionEffect(gameState.currentBattleAlien.x, gameState.currentBattleAlien.y);
                
                // Close battle after delay
                setTimeout(() => {
                    elements.battleModal.style.display = 'none';
                    renderMaze();
                }, 1500);
            }
        }
        
        // Show math question in battle
        function showMathQuestionInBattle() {
            elements.battleModal.style.display = 'none';
            showMathQuestion();
        }
        
        // Flee from battle
        function fleeFromBattle() {
            gameState.lives--;
            updateUI();
            
            elements.battleResult.textContent = `Kamu lari dari pertempuran dan kehilangan 1 nyawa!`;
            
            // Close battle after delay
            setTimeout(() => {
                elements.battleModal.style.display = 'none';
                
                if (gameState.lives <= 0) {
                    gameOver();
                } else {
                    renderMaze();
                }
            }, 1500);
        }

        // Show level complete
        function showLevelComplete() {
            const planet = gameState.planets[gameState.level - 1] || gameState.planets[gameState.planets.length - 1];
            elements.completedPlanetDisplay.textContent = planet.name;
            elements.levelCompleteModal.style.display = 'flex';
            
            // Increase weapon power for next level
            gameState.weaponPower += 2;
            updateUI();
        }
        
        // Go to next level
        function nextLevel() {
            gameState.level++;
            
            // Check if game completed
            if (gameState.level > gameState.planets.length) {
                alert('Selamat! Kamu telah menyelamatkan semua planet!');
                gameState.level = 1;
            }
            
            elements.levelCompleteModal.style.display = 'none';
            startGame();
        }
        
        // Game over
        function gameOver() {
            elements.gameOverModal.style.display = 'flex';
        }
        
        // Restart game
        function restartGame() {
            gameState.level = 1;
            gameState.lives = 3;
            gameState.weaponPower = 5;
            elements.gameOverModal.style.display = 'none';
            startGame();
        }

        // Toggle pause
        function togglePause() {
            gameState.isPaused = !gameState.isPaused;
            elements.pauseBtn.textContent = gameState.isPaused ? '▶️' : '⏸️';
        }

        // Show hint
        function showHint() {
            gameState.showHint = !gameState.showHint;
            renderMaze();
        }

        // Show explosion effect
        function showExplosionEffect(x, y) {
            const cell = document.querySelector(`.cell:nth-child(${y * gameState.mazeSize + x + 1})`);
            if (!cell) return;
            
            const explosion = document.createElement('div');
            explosion.className = 'explosion';
            explosion.style.animation = 'explosion 0.5s forwards';
            cell.appendChild(explosion);
            
            setTimeout(() => {
                cell.removeChild(explosion);
            }, 500);
        }

        // Show health up effect
        function showHealthUpEffect(x, y) {
            const cell = document.querySelector(`.cell:nth-child(${y * gameState.mazeSize + x + 1})`);
            if (!cell) return;
            
            const healthUp = document.createElement('div');
            healthUp.className = 'health-up';
            healthUp.style.animation = 'health-up 0.5s forwards';
            cell.appendChild(healthUp);
            
            setTimeout(() => {
                cell.removeChild(healthUp);
            }, 500);
        }
        
        // Show power up effect
        function showPowerUpEffect(x, y) {
            const cell = document.querySelector(`.cell:nth-child(${y * gameState.mazeSize + x + 1})`);
            if (!cell) return;
            
            const powerUp = document.createElement('div');
            powerUp.className = 'power-up';
            powerUp.style.animation = 'power-up 0.5s forwards';
            cell.appendChild(powerUp);
            
            setTimeout(() => {
                cell.removeChild(powerUp);
            }, 500);
        }

        // Show confetti effect
        function showConfetti() {
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                
                // Random position
                confetti.style.left = `${Math.random() * 100}%`;
                
                // Random color
                const colors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                
                // Random animation delay
                confetti.style.animation = `confetti-fall ${Math.random() * 3 + 2}s forwards`;
                confetti.style.animationDelay = `${Math.random() * 0.5}s`;
                
                document.body.appendChild(confetti);
                
                // Remove after animation
                setTimeout(() => {
                    document.body.removeChild(confetti);
                }, 5000);
            }
        }

        // Initialize the game when the page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>